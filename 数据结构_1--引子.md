# 			数据结构

## 学什么

- 如何用程序代码 把现实世界的问题信息化
- 如何用计算机高效处理这些信息从而创造价值






## 一、 数据

计算机专业人员，会用数据描述世界

数据是**信息的载体**，是描述客观事物属性的数、字符及所有能输入到计算机中并**被计算机程序识别和处理**的符号的集合。数据是计算机程序加工的原料。





### 1.1 数据元素

**数据元素**是数据的基本单位，通常作为一个整体进行考虑和处理。





### 1.2 数据项

一个数据元素可由多个**数据项**组成，数据项是构成数据元素的不可分割单最小单位

数据项可以再分的话，称之为**组合项**



- 一个账号是一个数据元素，账号的昵称，性别，生日等是数据项，其中生日由年月日组成，是组合项。







### 1.3 数据对象

数据对象是具有**相同性质**的**数据元素的集合**，是数据的一个子集。



- 所有的qq账号就是一个数据对象






### 1.4 数据结构

数据结构是**相互之间存在一种或多种特定关系**的**数据元素的集合**



- 同一个数据对象里的数据元素，可以组成不同的数据结构
- 数据对象强调**相同性质**，数据结构强调**关系**






## 二、数据结构三要素

数据结构三要素是 <u>**逻辑结构**</u>、<u>**数据运算**</u>、<u>**物理结构**</u>





### 2.1 逻辑结构

分为 <u>集合、线性、树形、图状</u> 结构



- 集合：各个元素同属一个集合，别无其他关系
- 线性：数据元素是一对一关系，除首位元素，都有唯一前驱，除末尾，都有唯一后驱
- 树型：数据元素之间一对多关系
- 图结构： 数据元素之间多对多关系





### 2.2 数据运算

结合逻辑结构、实际需求来定义基本运算



- 逻辑结构和数据运算    -->	定义一种数据结构
- 物理结构          -->   如何用计算机实现数据结构



### 2.3 物理结构（存储结构）

如何用计算机表示数据元素的逻辑关系



#### 顺序存储

把<u>逻辑上相邻的元素存储在**物理上也相邻**的存储单元</u>			

**存储单元的邻接关系** 体现 元素之间的关系

![](https://pic.imgdb.cn/item/66b47df9d9c307b7e9e01ba9.png)





#### 链式存储

逻辑上相邻的元素在物理位置上不相邻，借助指示元素**存储地址的指针**来表示元素之间的逻辑关系

![](https://pic.imgdb.cn/item/66b47d7ed9c307b7e9ded15e.png)







#### 索引存储

在存储元素信息时，建立附加的索引表。索引表中的每项称为索引项。

索引项的一般形式 ： （关键字，地址）

![](https://pic.imgdb.cn/item/66b47d10d9c307b7e9ddb265.png)





#### 散列存储

根据元素的关键字直接计算出元素的存储地址，又称 **哈希存储**



- 除顺序存储外，都称为 <u>非顺序存储、离散存储</u>

  ​

#### * 不同的存储结构

- 顺序结构，物理上必须连续，非顺序结构，物理上可以离散
- 不同存储结构，会影响 **存储空间分配的方便程度**


- 不同存储结构，会影响 **对数据运算的速度**




### 2.4 补充

#### * 数据类型、抽象数据类型

数据类型：

- 原子类型。其值不可分解的数据类型，如bool、int等。
- 结构类型。其值可以再分的数据类型，如结构体。



抽象数据类型：（Abstract  Data Type，ADT）

- 就是数据结构





## 三、算法





### 什么是算法？

**程序 = 数据结构 + 算法**



**数据结构**：如何用数据描述现实世界的问题。

**算法**：如何高效地出来这些数据，以解决实际问题





### 算法的特性

- **有穷性**。一个算法必须在执行**有穷步**之后结束，每一步都在有穷时间内完成。



- **确定性**。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。



- **可行性**。算法描述的步骤都可以已经实现的**基本运算执行有限次**来实现。
- **输入**。一个算法有零个或多个输入，输入取自于某个特定的对象的集合。
- **输出**。一个算法有一个或多个输出，输出与输入有着某种特定关系。



好算法特质：

- **正确性**
- **可读性**
- **健壮性**，输入非法数据时，能适当作出反应或进行处理，**不会产生莫名其妙的输出结果**
- **高效率**与**低存储**，时间复杂度和空间复杂度低




### 算法效率的度量



#### 时间复杂度

事前预估算法时间开销 **T(n)** 与问题规模 **n** 的关系

在**只考虑阶数高**的部分时，可以用**大O**表示**”同阶“**

​		$T(n) = O(f(n))   $

等价于：$\lim\limits_{n \to +\infty} \frac{T(n)}{f(n)}$



**常见复杂度**

$O(1)<O(\log_{2}n)<O(n)<O(n\log_{2}n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)$

**[ 空间和时间都适用 ]**





#### 空间复杂度



无论**问题规模n**如何变化，算法运行所需内存空间固定不变

```c
void hello(int n) {
    int i=1;
    while(i<=n){
        i++;
        print("hello")
}
}
```

此时算法的空间复杂度为 $S(n) = O(1)$

(注：S 代表 space)





```c
void test(int n){
    int flag[n];
    ...
}
```

复杂度    $O(n)$



```c
void test(int n){
    int flag[n][n];
    int other[n];
    ...
}
```

复杂度  $O(n^2)$




