# 			树与二叉树
## 树的逻辑结构

逻辑结构：该数据结构，理论逻辑上由什么组成。

### 树的基本概念

树是**无序的** 

[![](https://pic.imgdb.cn/item/6718a932d29ded1a8ca0c9e3.png)](https://pic.imgdb.cn/item/6718a932d29ded1a8ca0c9e3.png)



空树——结点数为0的树



非空树的特性：

- 有且仅有一个根结点
- 没有后继的结点——叶子结点
- 有后继的结点——分支结点
- 处了根结点外，任何结点都**有且仅有一个前驱**
- 每个结点可以有0个或多个后继



 任何一个树，都可以看作一个根结点和若干个不相干的子树(空树也是树)构成。



操作系统的文件目录——树的应用



**路径** 

结点之间的路径——只能**从上往下** 



属性：

结点的**层次**（深度）——从上往下数

结点的**高度**——从下往上数

树的高度（深度）—— 总共多少层



**结点的度** —— 有几个分支 ,拥有子树的个数

**树的度** —— 树中各结点的度的最大值



**叶子结点** 度为0

**分支结点** 度不为0



层序编号：将树中结点按照从上至下，从左至右编号



### 有序树、无序树、森林

有序树——逻辑上看，树中结点的各子树从左至右是**有次序**的，不能互换



有序树——逻辑上看，树中结点的各子树从左至右是**无次序**的，不能互换



森林——是m棵互不相交的树都集合

森林可以和树相互转化



### 树的性质

#### 常见性质1： 

**结点数=总度数(各结点的度数之和)+1**



#### 常见性质2： 

**度为m的树，m叉树的区别**

```
树的度，各结点的度的最大值

m叉树——每个结点最多只能有m个分支

```





#### 常见性质 3： 

**度为m的树第i层至多有m的i-1次方个结点**



| 层数 | 最多结点数 |
| ---- | ---------- |
| 1    | 1          |
| 2    | m          |
| 3    | m*m        |

#### 常见性质 4：

**高度为h的m叉树 至多 有( m的h次方-1 )除以 (m-1 )个结点** 



1 + m + m*m + ... + m的h-1次方

等比数列求和



#### 常见性质 5：

**高度为h的m叉树至少有h个结点** 

**高度为h，度为m的树至少有 h+m-1个结点**  



每层一个结点



#### 常见性质 6：

具有n个结点的m叉树都最小高度为 [logm (n(m-1)+1)]



 

### 树的遍历

从根结点出发，按照某种次序访问树中所有结点，使得每个结点被访问一次，

且仅被访问一次





**后序遍历** 

从左往右，从下往上遍历



**(前)先序遍历** 

从左往右，从上往下遍历



**层序遍历**

将树中结点按照从上至下，从左至右编号



### 二叉树

二叉树是 n 个结点 的有限集合：

- n= 0,空二叉树
- 由一个根结点和两个互不相交的左子树和右子树。左右子树也是二叉树。



特点：

- 每个结点至多只有两棵子树
- 二叉树 是 **有序的**，次序不能颠倒，左右子树不能颠倒



二叉树的五种状态

- 空二叉树
- 只有根结点
- 只有左子树
- 只有右子树
- 左右子树都有



#### 满二叉树

一棵高度为h，且包含 2的h次方 -1 个结点 的二叉树

最后一层 叶子是满的



特点：

- 叶子结点只能出现在最下一层
- 只有度为0和度为2的结点
- 层序编号，从1开始编号，结点i的左孩子为2i，右孩子为2i+1;结点i的父结点为[i/2]（如果有的话）



#### 完全二叉树

当二叉树中每个结点都与高度相同的满二叉树中，层序编号1~n(结点数) 对应相同时，就称为完全二叉树。



满二叉树是一种特殊的完全二叉树

特点：

- 只有最后两层可能有叶子结点
- 最多只有一个结点
- i>[n/2]为叶子结点，i<=[n/2]为分支结点




#### 二叉排序树

`左子树`上所有节点的关键字均小于根结点的关键字

`右子树`上所有结点的关键字均大于根结点的关键字

左子树和右子树又各是一棵二叉排序树



<p>可用于元素的排序、搜索</p> 



#### 平衡二叉树

树上任一结点的左子树和右子树的深度之差不超过1。



平衡二叉树能有更高的搜索效率

[![](https://pic.imgdb.cn/item/6721e798d29ded1a8c1f450e.png)](https://pic.imgdb.cn/item/6721e798d29ded1a8c1f450e.png) 



### 二叉树的性质

#### 常用性质1：

设非空二叉树中度为0，1和2的结点个数分别为n0,n1和n2,则 **n0=n2+1** 

(叶子结点比二分支结点多一个)

```
结点总数为n
n = n0+n1+n2
n = n1 + 2*n2 + 1
//树的结点数 = 总度数 + 1
```



#### 常用性质2：

二叉树第i层至多有$2^{i-1}$个结点





### 二叉树遍历







## 树的存储结构

树是一个非线性结构，但是我们在计算机中 用线性结构实现



### 二叉树顺序存储

[![](https://pic.imgdb.cn/item/6719de73d29ded1a8ca9f928.png)](https://pic.imgdb.cn/item/6719de73d29ded1a8ca9f928.png) 

```c
#define MaxSize 100
struct TreeNode {
    ElemType value;		//结点中的数据元素
    bool isEmpty;	//结点是否为空
};

struct TreeNode t[MaxSize];

//初始化，所有节点设为空
for (int i=0; i< MaxSize; i++) {
	t[i].isEmpty=true;	
}
```



需要体现结点之间的关系

完全二叉树

```
i的父类	 i/2
i的左孩子	2i
i的右孩子 	2i + 1
```



树的顺序存储

将树补全为完全二叉树，补来的结点设为空。

问题：

​	浪费空间，补来的节点需要作标志



### 二叉链表

更常用

```c
typedef struct BiNode
{
	ElemType data;
	struct BiNode *lchild,*rchild;	//指向左孩子和右孩子的指针
}BiNode,*BiTree;
```



n个结点 有 2n个指针，有n+1个指针是空的。



```
//定义一棵空树
BiTree root = NULL;

//插入根结点
root = (BiTree) malloc(sizeof(BiNode));
root->data={1};
root->lchild=NULL;
root->rchild=NULL;

//插入新结点
BiTNode *p=(BiTNode *)malloc(sizeof(BiTNode));
p->data={2};
p->lchild=NULL;
p->rchild=NULL;
root->lchild=p;
```



虽然找到孩子很简单，但是若要找父亲则是需要从根结点遍历，十分麻烦

这时我们就需要三叉链表

#### 

### 三叉链表

```
typedef struct BiTNode{
	ElemType data;
	struct BiTNode *lchild,*rchild;
	struct BiTNode *parent;
}BiTNode,*BiTree;
```



不经常找父类就直接用二叉链表



### 遍历

根据二叉树的 递归特性 制订的 **遍历规则** 



递归特性：

```
1.要么是个空二叉树
2.要么是由 “ 根节点 + 左子树 + 右子树 ” 组成的二叉树
```



对于非空二叉树采用的遍历规则

- 先序遍历

```
根左右 NLR
```


- 中序遍历

```
左根右 LNR
```

- 后序遍历

```
左右根 LRN
```



**每遍历到一个树节点，都要执行对应的遍历规则** 

一个算数表达式的树构建，可以通过前中后遍历，输出前中后缀表达式



- 层序遍历

```\
初始化一个辅助队列
根结点入队
若队列非空，队头结点出队，访问该结点，将其左，右孩子插入队尾。
（入队出队实际只用指针就行，无需使用实际节点）
```











#### 前序遍历

```
void PreOrder(BiTree T)
{
    if (T!=NULL){
        visit(T);
        PreOrder(T->lchild);	//递归遍历左子树
        PreOrder(T->rchild);	//递归遍历右子树
    }
}
```



#### 后序遍历

```
void PostOrder(BiTree T)
{
    if (T!=NULL){
        PreOrder(T->lchild);	//递归遍历左子树
        PreOrder(T->rchild);	//递归遍历右子树
        visit(T);
    }
}
```



#### 中序遍历

```
void InOrder(BiTree T)
{
    if (T!=NULL){
        PreOrder(T->lchild);	//递归遍历左子树
        visit(T);
        PreOrder(T->rchild);	//递归遍历右子树
    }
}
```



非递归

```
LNR

左 根 右
当左子树存在时，继续以左为根进行中序，此时左子树的父结点需要入栈保存
栈内结点访问后，需要出栈
```



#### 层序遍历

```
void LevelOrder(BiTree T){
	LinkQueue Q;
	InitQueue(Q);
	BiTree p;
	EnQueue(Q,T);
	while(!IsEmpty(Q)){
		DeQueue(Q,p);			//队头结点出队
		visit(p);				//访问出队结点
		if(p->lchild!=NULL)
			EnQueue(Q,p->lchild);	//左孩子入队
		if(p->rchild!=NULL)
			EnQueue(Q,p->rchild);	//右孩子入队
	
	}
}
```



### 求深度

```
int treeDepth(BiTree T){
	if(T==NULL){
		return 0;
	}
	else {
		int l=treeDepth(T->lchild);
		int r=treeDepth(T->rchild);
		//树的深度=Max(左子树深度，右子树深度)+1
		return l>r?l+1:r+1;
	}
}
```



### 构造二叉树

```
只给出一棵二叉树的 前/中/后/层 序遍历序列中的一个，不能唯一确定一棵二叉树
```

但我们可以多种序列来确定二叉树



#### 前序+中序 遍历序列

```
前序的首个结点就是根结点
中序的根节点左边就是左子树结点，右边就是右子树结点
```



#### 后序+中序 遍历序列

```
后序的尾结点就是根结点
中序的根节点左边就是左子树结点，右边就是右子树结点
```



#### 层序+中序 遍历序列

```
层序遍历   根 左子树根 右子树根 左子树的左子树的根 左子树的右子树的根 ...
中序的根节点左边就是左子树结点，右边就是右子树结点
```



### 线索二叉树

普通二叉树

- 不能从指定节点开始中序遍历

```
因为节点指针只指向孩子，无法回溯。
只能从根结点开始遍历
```

- 不能找到指定节点在中序遍历序列的前驱/后继

```
思路：
从根结点进行一次中序遍历，q指针记录当前访问结点，pre指针记录中序遍历时上一个被访问的节点
1. q==指定结点时，pre为前驱
2. pre==指定结点时，q为后继
```

缺点：不方便，必须从根开始





线索二叉树		方便遍历

- 线索化

```
n个结点有n+1个空指针，可用来记录遍历序列的前驱、后继信息
而 记录 前驱后继 的指针 称为 “线索”
```

- 左空子树

```
指向序列前驱
```

- 右空子树

```
指向序列后继
```



没有线索的节点怎么找后继？？ 详情见后续



#### 代码实现 

- 定义线索二叉树

```
typedef struct ThreadNode{
	ElemType data;
	struct ThreadNode *lchild,*rchild;
	int ltag,rtag;			//左、右线索 标志 0为孩子，1为线索
}ThreadNode,*ThreadTree;
```



- 中序遍历线索化

```c
//记录指定结点的前驱
ThreadNode *pre=NULL;

//中序遍历二叉树，遍历到同时进行线索化
void InThread(ThreadTree T){	
	if(T!=NULL){		
		InThread(T->lchild);	//中序遍历左子树
		visit(T);				//访问根结点
		InThread(T->rchild);	//中序遍历右子树
	}
}

//线索化过程		
void visit(ThreadNode *q){
	if(q->lchild==NULL){	//左子树为空，则建立前驱线索
		q->lchild=pre;
		q->ltag=1;
	}
	if(pre!=NULL&&pre->rchild=NULL){
		pre->rchild=q;		//建立前驱结点的后继线索(若有的话)
		pre->rtag=1;
	}
	pre=q;		
}


//中序线索化二叉树
void CreateInThread(ThreadTree T){
	pre==NULL;		
	if(T!=NULL){	//非空二叉树线索化
		InThread(T);
		if(pre->rchild=NULL)		
			pre->rtag=1;		//处理遍历最后一个结点
	}
}

```

首结点的前驱线索为NULL，ltag=1;尾结点的后继线索为NUL，rtag=1;



- 先序线索化

```
唯一不同的:
//先序遍历二叉树，遍历到同时进行线索化
void PreThread(ThreadTree T){	
	if(T!=NULL){		
	 	visit(T);				//访问根结点
	 	if(T->ltag==0){		
		PreThread(T->lchild);	//在非线索的情况下，中序遍历左子树
		}
		PreThread(T->rchild);	//中序遍历右子树
	}
}

```

先序线索化，我们将左空子树 指向 前驱 后，由于会向左继续遍历，所以会向左进入前驱从而进入循环，所以我们需要判断左子树是线索还是子树。



- 后续线索化

```
与中序相同
```



#### rtag=0找中序后继

- 找指定节点p的中序后继   且   p->rtag=0

```
找到p结点的p->rchild子树中第一个中序遍历的结点
LNR		最左是第一个，否则就是根
```





- 代码实现

```
//找到以p为根(此p是函数参数p)的子树中，第一个被中序遍历的结点
ThreadNode *Firstnode(ThreadNode *p){
	//循环找到最左下结点（不一定是叶子结点）
	while(p->ltag==0)	p=p->lchild;
	return p;
}

//在中序线索二叉树中找到结点p的后继节点
ThreadNode *Nextnode(ThreadNode *p){
	//右子树中最左下结点
	if(p->rtag==0)	return Firstnode(p->rchild);
	else	return p->rchild;
}
```



#### ltag=0找中序前驱

- 找指定结点p的中序前驱 且 p->ltag=0

```
找到p结点的p->lchild子树中最后一个被中序遍历的结点
LNR		最右是最后一个，否则是根
```

- 代码实现

```
ThreadNode *Lastnode(ThreadNode *p){
	//循环找最右下节点
	while(p->rtag=0)	p=p->rchild;
	return p;		//否则返回根		LNR
}

ThreadNode *Prenode(ThreadNode *p){
	//右子树中最右下结点
	if(p->rtag==0)	return Lastnode(p->rchild);
	else	return p->rchild;
}
```





#### 线索实现非递归中序遍历

```
void Inorder(ThreadNode *T){
	for(ThreadNode *p=Firstnode(T);p!=NULL;p=Nextnode(p))
		visit(p);
}
```



#### 线索实现非递归中序逆遍历

```
void RevInorder(ThreadNode *T){
	for(ThreadNode *p=Lastnode(T);p!=NULL;p=Prenode(p))
		visit(p);
}
```



#### 先序后继

```
NLR
p有左孩子，后继为p->lchild
p有右孩子无左孩子，后继为p->rchild
p有右孩子和左孩子，后继为p->lchild
```





#### 先序前驱

- 要用三叉链表，除非从根开始遍历

```
找指定结点p的前驱
四种情况：
p为其父结点的左孩子		,前驱为 p->parent
p为其父结点的右孩子，左兄弟非空,前驱为p->parent->lchild
p为其父结点的右孩子，左兄弟为空,前驱为p->parent
p为根，没有前驱,	前驱为NULL
```



#### 后序前驱

```
LRN
指定结点有右孩子	前驱为p->rchild
指定结点没有右孩子	前驱为p->lchild
```



#### 后序后继

- 要用三叉链表，除非从根开始遍历

```
p为其父结点的右结点，后继为p->parent
p为其父结点的左结点，且右兄弟为空，后继为p->parent
p为其父结点的左结点，且右兄弟非空，后继为p->parent->rchild
p是根，没有后继，后继为NULL
```





### 树的存储

#### 双亲表示法(顺序存储)

```
#define MaxSize 100
typedef sturct {
    ElemType data;
    int parent;		//父结点的下标
}PTNode;

typedef struct{	
	PTNode nodes[MaxSize];		
	int n;			//结点数
}PTree;	

//根节点的parent 为 -1
```

找孩子，可以利用节点的下标，然后在所有节点中遍历，效率不高。



- 该方法删除节点后，需要将尾结点移动到删除后的空白位置中

```
提高遍历效率
```

- 删除结点后，其子树也要被删除，这就要找孩子，需要全局遍历





#### 孩子表示法（顺序+链式存储）

```
typedef struct Node{
    int data;	//存放孩子下标
    struct Node;
}TNode;

struct PNode {
    T.data;
    int parent;
    TNode *child;
};
```



```
struct CTNode{
	int child;		//孩子结点的数组下标
	struct CTNode *next;	//下一个孩子
}；

typedef struct{
	ElemType data;
	struct CTNode *firstChild;	//第一个孩子
}CTBox;

typedef struct{
	CTBox nodes[MaxSize];
	int n,r;	//结点树和根的位置
}
```





#### 孩子兄弟表示法(链式存储)

两个指针，一个指向兄弟，一个指向左侧第一个孩子

**本质：和二叉链表的存储结构一致（二叉指向两个子结点）** 

```
typedef struct CSNode{
	ElemType data;
	struct CSNode *firstchild,*nextsibling;	
	//第一个孩子(左)和右兄弟指针(右)
}CSNode,*CSTree;
```

这是一个**树和二叉树**的转化，我们之后就可以利用二叉树操作来处理树





#### 二叉树和森林的转换

将森林中的每棵树转换为二叉树，之后每棵二叉树的根结点当作兄弟结点



### 树、森林的遍历

#### 树的先根遍历

- 说明

```
若树非空，先访问根结点，再依次对每棵子树进行先根遍历
```



- 伪代码实现

```
void PreOrder(TreeNode *R){
	if (R!=NULL){
		visit(R);	//访问根结点
		while(R还有下一个子树T)
			PreOrder(T);	//先根遍历下一棵子树
	}
		
}
```

具体还要考虑定义的树的结构



- 注意

```
等价于树对应的二叉树的先序遍历
```



#### 树的后根遍历

- 说明

```
若树非空，先一次对每棵子树进行后根遍历，最后在访问根结点
```

- 伪代码实现

```
void PreOrder(TreeNode *R){
	if (R!=NULL){
		while(R还有下一个子树T)
			PostOrder(T);	//先根遍历下一棵子树
	 	visit(R);	//访问根结点
	}
		
}
```

- DFS

```
又称：“深度优先遍历”，即DFS，深度优先搜索
```

- 注意

```
树的后根遍历序列与对应二叉树的中序序列相同
```



#### 树的层次遍历（队列实现）

- 说明

```
若树非空，则根结点入队
若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队
重复2操作直到队列为空
```

- BFS

```
又称：广度优先遍历（即BFS 广度优先搜索）
```

#### 森林的先序遍历

- 说明

```
等效于依次对每个树进行先根遍历
等效于森林转换为二叉树，二叉树进行先序遍历
```



#### 森林的中序遍历

- 说明

```
等效于依次对每个树进行后根遍历
等效于对应二叉树的中序遍历
```



### 二叉树建立

- 给叶子结点的空指针用符号“#”表示
- 前序遍历序列建立二叉链表

```
输入前序遍历序列,输入“#”代表空结点（空子树）
```

```
BiNode *creat(BiTree T){		//构建一个二叉树
	char ch;
	cin >> ch;
	if(ch=='#')	T=NULL;
	else{
		T=(BiTree)malloc(sizeof(BiNode));
		T->data=ch;
		T->lchild=creat(T->lchild);
		T->rchild=creat(T->rchild);
	}
	return T;
}
```







### 基本操作

位序为 i 的节点

- i的左孩子 	—— 2i
- i的右孩子        ——2i+1
- i的父结点        —— [i/2]
- i所在的层次    ——[log2(n+1)] 或 [log2 n]+1






### 树和二叉树的对应关系

树转化为二叉树：

- 同父同级兄弟加线
- 保留父结点和第一个子结点的连线，删除其他连线，之前加的线不用删。
- 顺时针转动，层次分明

同级兄弟连线为右子树，孩子连线为左子树。



**树的后序遍历等价与二叉树的中序遍历** 





### 森林转化为树 

森林中的每棵树转换为二叉树，按照次序将每一棵树的根结点连接，第一棵树的根结点为总树的根



### 二叉树转化为森林

二叉树的根结点：

如果有右孩子，一定有森林。

如果没有右孩子，就没有森林



建立树，用递归和非递归实现树的遍历，





## 哈夫曼树

### 相关名词  

- `结点的权`

```
表示结点的权重，重要性
（或是某种现实含义的值）
```

- `结点的带权路径长度`

```
从树的根到该结点的路径长度（经过的边数）与该结点上权值的乘积
```

- `树的带权路径长度`

```
树中所有叶子结点的带权路径长度之和（WPL），即Weighted Path Length
```



### 定义

```
在含有n个带权叶子结点的二叉树中，其中带权路径长度最小的二叉树称为哈夫曼树，也称最优二叉树
```



### 哈夫曼树的构造

给定n个有具体权值的结点，构造哈夫曼树的算法描述如下：

- 组成森林F

```
从n个有权值的结点分别作为仅含一个结点的二叉树，构成森林F
```



- 构造哈夫曼树结点

```
将F中选取两棵根结点权值最小的树作为新结点的左右子树，并将左右子树的权值之和赋值给新节点
```



-  重复步骤

```
将之前构建新结点左右子树的两个树，从F中移除，新构建的树移入F中
重复构造哈夫曼树结点的步骤
```



**特性**

- 每个初始结点最终都成为叶子节点，权值越小的街道那到根结点的路径越大

- 哈夫曼树的结点总数为`2n-1`
- 哈夫曼树都不存在度为1的结点
- 哈夫曼树不唯一，但`WPL`必然相同且为最优

```
当构建哈夫曼结点时，当F中有多个相同权值的根结点树时，我们有多种构建方式
```







### 哈夫曼编码

 

固定长度编码

```
ASCII编码，8个bit位表示一个字符
一个字节Byte为8个bit
```

可变长度编码

```
不同字符允许用不等长的二进制为表示

若没有一个编码时另一个编码的前缀，则称“前缀编码”	（叶子结点表示字符）
```



哈夫曼编码

```
字符集中的每个字符作为一个叶子结点，各个字符出现的频度多为结点的权值，根据此来构建哈夫曼树
```



## 并查集

### 逻辑结构

```
并查集 是逻辑结构——集合的一种具体实现，
且只进行“并”和"查"两种基本操作

# 数据元素之间的逻辑关系：集合、线性表、树、图
```

```
将各个元素划分为若干个互不相交的子集

两个元素之间的关系有：
属于一个集合
不属于一个集合
```

回顾

```
森林是m棵互不相交的树的集合

所以我们可以:
将一个子集的元素，构成一棵树
不同子集代表不同的树，构成森林
```

- 如何`查`到一个元素到底属于哪一个集合

```
从指定元素一路找到树的根结点

#判断两个元素是否属于同一个集合
查两个元素的树的根结点，判断是否相同
```

- 把两个集合`并`为一个集合

```
让一棵树成为另一棵树的子树
```



### 存储结构

```
查：一路向北，找到根结点
并：一棵树的根的父结点指向另一棵树的根

采取：双亲表示法 

```



代码实现

`初始化`

```c
#define Size 13
int UFSets[Size];

void Initial(int S[]){
	for(int i=0;i<Size;i++){
		S[i]=-1;
	}
}
```

`查 Find`

```c
//查找第x号元素的集合的根
int Find(int S[],int x){
	while(S[x]>=0)
		x=S[x];				//循环寻找x的根
	return x;			
}
```

`并 Union`

```c
void Union(int S[],int Root1,int Root2){
	if(Root==Root2)	return;
	//不同集合才能合并
	S[Root2]=Root1;			//将Root2的父结点为Root1
}
```

 



`优化Union`

```
在每次Union构建树都时候尽可能让树不长太高

1. 用根结点的绝对值表示该树的结点总数(若树有6个结点，根结点的值赋为-6)
2. Union操作，让小树合并到大树，不能让大树合并到子树上

合并后，记得将合并树的根赋为两树结点之和
```

`优化代码`

```c
void Union(int S[],int Root1,int Root2){
	if(Root1==Root2) return;
	if(S[Root1]>S[Root2]){
		S[Root2]=Root1;
		S[Root1] += S[Root2];
	}
	else{
		S[Root1]=Root2;
		S[Root2]+=S[Root1];
	}
}
```

`此构建的树高不会超过`

$|\log_{2}n|+1$

优化此`union`可以将`Find`的时间复杂度从$O(n)$优化到$O(log_{2}n)$





`优化find`

```
压缩路径

将指定结点到根结点的查找路径中的各个结点全部指向根结点
在下一次查找时，我们路过之前的某些结点，会直接找到根结点
```

`代码实现`

```
int Find(int S[],int x){
	int root=x;
	while(S[root]>=0) root=S[root];	//循环找根
	//此时root就是树的根
	while(x!=root){			//遍历查找的路径
		int t=S[x];	//记录父结点
		S[x]=root;	//指向root
		x=t;		//遍历到父结点
	}
	return root;
}
```

时间复杂度十分接近$O(1)$



`根本原理`

```
让树变矮
```



[![](https://pic.imgdb.cn/item/672b1049d29ded1a8c9f1720.png)](https://pic.imgdb.cn/item/672b1049d29ded1a8c9f1720.png) 

 
